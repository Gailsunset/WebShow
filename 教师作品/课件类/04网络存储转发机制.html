<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Store and Forward Network Simulation 3D</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #050510; font-family: 'Arial', sans-serif; }
        #info {
            position: absolute;
            top: 20px;
            width: 100%;
            text-align: center;
            color: #00ffff;
            font-size: 18px;
            text-shadow: 0 0 10px #00ffff;
            pointer-events: none;
            z-index: 10;
        }
        #status-panel {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 20, 40, 0.8);
            border: 1px solid #0088ff;
            padding: 15px 30px;
            border-radius: 8px;
            color: white;
            font-size: 16px;
            text-align: center;
            min-width: 300px;
        }
        .highlight { color: #ffaa00; font-weight: bold; }
    </style>
</head>
<body>
    <div id="info">网络存储转发机制 (Store-and-Forward) 3D 演示<br><span style="font-size:12px; color:#aaa;">拖动旋转 | 滚轮缩放</span></div>
    <div id="status-panel">当前状态: <span id="status-text" class="highlight">准备中...</span></div>

    <!-- Import Three.js from CDN -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { FontLoader } from 'three/addons/loaders/FontLoader.js';
        import { TextGeometry } from 'three/addons/geometries/TextGeometry.js';

        // --- 场景设置 ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x050510);
        scene.fog = new THREE.FogExp2(0x050510, 0.02);

        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 15, 20);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;

        // --- 灯光 ---
        const ambientLight = new THREE.AmbientLight(0x404040, 2); // 柔和环境光
        scene.add(ambientLight);

        const dirLight = new THREE.DirectionalLight(0xffffff, 2);
        dirLight.position.set(5, 10, 7);
        dirLight.castShadow = true;
        scene.add(dirLight);

        const pointLight = new THREE.PointLight(0x0088ff, 2, 50);
        pointLight.position.set(0, 5, 0);
        scene.add(pointLight);

        // --- 地面网格 ---
        const gridHelper = new THREE.GridHelper(50, 50, 0x112233, 0x0a1122);
        scene.add(gridHelper);

        // --- 数据定义 ---
        const nodesData = [
            { id: 0, x: -10, z: 0, label: "发送端 (Source)", type: "source" },
            { id: 1, x: -4, z: 4, label: "节点 A", type: "router" },
            { id: 2, x: 4, z: -4, label: "节点 B", type: "router" },
            { id: 3, x: 10, z: 0, label: "接收端 (Dest)", type: "dest" }
        ];

        const nodeObjects = [];
        const labelSprites = [];

        // --- 材质 ---
        const nodeMatBase = new THREE.MeshStandardMaterial({ color: 0x0066cc, roughness: 0.2, metalness: 0.8 });
        const nodeMatActive = new THREE.MeshStandardMaterial({ color: 0xff3300, emissive: 0xaa1100, roughness: 0.2 });
        const nodeMatSource = new THREE.MeshStandardMaterial({ color: 0x00cc66, roughness: 0.2 });
        
        // --- 创建 3D 文字标签函数 ---
        function createLabel(text, position) {
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.width = 512; 
            canvas.height = 128; 
            
            context.fillStyle = 'rgba(0,0,0,0)'; // 透明背景
            context.fillRect(0, 0, canvas.width, canvas.height);
            
            context.font = 'Bold 40px Arial';
            context.fillStyle = 'white';
            context.textAlign = 'center';
            context.shadowColor = "rgba(0,0,0,1)";
            context.shadowBlur = 4;
            context.fillText(text, canvas.width / 2, canvas.height / 2 + 10);

            const texture = new THREE.CanvasTexture(canvas);
            const spriteMaterial = new THREE.SpriteMaterial({ map: texture });
            const sprite = new THREE.Sprite(spriteMaterial);
            
            sprite.position.copy(position);
            sprite.position.y += 2.5; // 悬浮在节点上方
            sprite.scale.set(6, 1.5, 1);
            
            scene.add(sprite);
            return sprite;
        }

        // --- 构建节点 ---
        const geometryCylinder = new THREE.CylinderGeometry(1, 1, 1, 32);
        const geometryBox = new THREE.BoxGeometry(1.5, 1.5, 1.5);

        nodesData.forEach(data => {
            let mesh;
            if (data.type === "router") {
                mesh = new THREE.Mesh(geometryCylinder, nodeMatBase.clone());
            } else {
                mesh = new THREE.Mesh(geometryBox, data.type === "source" ? nodeMatSource : nodeMatBase.clone());
            }
            
            mesh.position.set(data.x, 0.5, data.z);
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            mesh.userData = data; // 存储元数据
            
            scene.add(mesh);
            nodeObjects.push(mesh);

            // 添加底座光圈
            const ringGeo = new THREE.RingGeometry(1.2, 1.5, 32);
            const ringMat = new THREE.MeshBasicMaterial({ color: 0x0088ff, side: THREE.DoubleSide, transparent: true, opacity: 0.5 });
            const ring = new THREE.Mesh(ringGeo, ringMat);
            ring.rotation.x = -Math.PI / 2;
            ring.position.y = 0.05;
            mesh.add(ring);

            createLabel(data.label, mesh.position);
        });

        // --- 连接线 ---
        const points = nodesData.map(n => new THREE.Vector3(n.x, 0.5, n.z));
        const lineGeo = new THREE.BufferGeometry().setFromPoints(points);
        const lineMat = new THREE.LineBasicMaterial({ color: 0x004488, linewidth: 2 });
        const line = new THREE.Line(lineGeo, lineMat);
        scene.add(line);

        // --- 数据包 (Packet) ---
        const packetGeo = new THREE.BoxGeometry(0.6, 0.6, 0.6);
        const packetMat = new THREE.MeshStandardMaterial({ color: 0xffaa00, emissive: 0xffaa00, emissiveIntensity: 2 });
        const packet = new THREE.Mesh(packetGeo, packetMat);
        scene.add(packet);

        // 粒子尾迹系统
        const particleCount = 20;
        const trailGeo = new THREE.BufferGeometry();
        const trailPos = new Float32Array(particleCount * 3);
        trailGeo.setAttribute('position', new THREE.BufferAttribute(trailPos, 3));
        const trailMat = new THREE.PointsMaterial({ color: 0xffaa00, size: 0.2, transparent: true, opacity: 0.6 });
        const trail = new THREE.Points(trailGeo, trailMat);
        scene.add(trail);

        // --- 动画状态逻辑 ---
        let currentNodeIndex = 0;
        let isMoving = false;
        let isStoring = false;
        let t = 0; // 插值因子
        const speed = 0.015; // 移动速度
        let storageTimer = 0;
        const storageDuration = 100; // 存储帧数 (约1.5秒)
        
        const statusText = document.getElementById('status-text');

        function updatePacket() {
            if (currentNodeIndex >= nodesData.length - 1) {
                // 到达终点，重置
                storageTimer++;
                if (storageTimer > 100) {
                    currentNodeIndex = 0;
                    t = 0;
                    storageTimer = 0;
                    isMoving = false;
                    isStoring = false;
                    packet.visible = true;
                    packet.position.copy(nodeObjects[0].position);
                    // 重置所有节点颜色
                    nodeObjects.forEach(n => {
                        if(n.userData.type === "router") n.material.color.setHex(0x0066cc);
                        if(n.userData.type === "dest") n.material.color.setHex(0x0066cc);
                        n.scale.set(1,1,1);
                    });
                } else {
                    statusText.innerText = "传输完成。等待重置...";
                    packet.visible = false;
                    // 终点闪烁
                    const destNode = nodeObjects[nodesData.length-1];
                    destNode.material.emissive.setHex(Math.sin(Date.now() * 0.01) > 0 ? 0x00ff00 : 0x000000);
                }
                return;
            }

            const startPos = nodeObjects[currentNodeIndex].position;
            const endPos = nodeObjects[currentNodeIndex + 1].position;

            if (isStoring) {
                // --- 存储阶段 (Store) ---
                storageTimer++;
                
                // 视觉效果：节点闪烁/变大
                const activeNode = nodeObjects[currentNodeIndex];
                const progress = storageTimer / storageDuration;
                
                // 模拟"填充"缓冲区
                activeNode.scale.y = 1 + Math.sin(progress * Math.PI) * 0.5;
                activeNode.material.color.setHex(0xff3300); // 红色表示忙碌/存储
                
                statusText.innerText = `节点 ${nodesData[currentNodeIndex].label} 正在存储数据... (${Math.floor(progress*100)}%)`;

                if (storageTimer >= storageDuration) {
                    isStoring = false;
                    isMoving = true;
                    storageTimer = 0;
                    packet.visible = true; // 数据包重新出现
                    activeNode.scale.set(1,1,1); // 恢复节点大小
                    activeNode.material.color.setHex(0x0066cc); // 恢复节点颜色
                    
                    // 如果是源节点，不需要存储过程，直接开始
                }
            } else if (isMoving) {
                // --- 转发/移动阶段 (Forward) ---
                t += speed;
                statusText.innerText = `正在转发至 -> ${nodesData[currentNodeIndex+1].label}`;

                if (t >= 1) {
                    // 到达下一个节点
                    t = 0;
                    isMoving = false;
                    currentNodeIndex++;
                    
                    // 只有到达中间路由器或终点时才进入存储状态
                    // 源节点直接发，不"接收"
                    if (currentNodeIndex > 0) {
                         // 开始存储
                        isStoring = true;
                        packet.visible = false; // 数据包进入节点内部
                    }
                } else {
                    // 线性插值移动
                    packet.position.lerpVectors(startPos, endPos, t);
                    // 增加一个小弧度，让跳跃更生动
                    packet.position.y = 0.5 + Math.sin(t * Math.PI) * 2;
                }
            } else {
                // 初始状态
                isMoving = true;
                // 如果是起点，不进入存储，直接走
                if (currentNodeIndex === 0) {
                    isStoring = false; 
                }
            }
        }

        function updateTrail() {
            if (!packet.visible) {
                // 隐藏尾迹
                for(let i=0; i<particleCount*3; i++) trailPos[i] = 9999;
                trailGeo.attributes.position.needsUpdate = true;
                return;
            }

            // 简单的尾迹算法：将之前的点向前移动
            for (let i = (particleCount - 1) * 3; i >= 3; i -= 3) {
                trailPos[i] = trailPos[i - 3];
                trailPos[i + 1] = trailPos[i - 3 + 1];
                trailPos[i + 2] = trailPos[i - 3 + 2];
            }
            // 头部是当前packet位置
            trailPos[0] = packet.position.x;
            trailPos[1] = packet.position.y;
            trailPos[2] = packet.position.z;

            trailGeo.attributes.position.needsUpdate = true;
        }

        // --- 渲染循环 ---
        function animate() {
            requestAnimationFrame(animate);
            controls.update();

            updatePacket();
            updateTrail();

            renderer.render(scene, camera);
        }

        // --- 窗口自适应 ---
        window.addEventListener('resize', onWindowResize, false);
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        animate();

    </script>
</body>
</html>